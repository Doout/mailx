
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mailx: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/valord577/mailx/auth.go (100.0%)</option>
				
				<option value="file1">github.com/valord577/mailx/dialer.go (66.0%)</option>
				
				<option value="file2">github.com/valord577/mailx/file.go (100.0%)</option>
				
				<option value="file3">github.com/valord577/mailx/msg.go (73.6%)</option>
				
				<option value="file4">github.com/valord577/mailx/msg_export.go (72.2%)</option>
				
				<option value="file5">github.com/valord577/mailx/sender.go (65.0%)</option>
				
				<option value="file6">github.com/valord577/mailx/writer.go (84.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package mailx

import (
        "errors"
        "net/smtp"
)

// @author valor.

// loginAuth implements the LOGIN authentication mechanism of the SMTP.
type loginAuth struct {
        username string
        password string
        host     string
}

func isLocalhost(name string) bool <span class="cov1" title="1">{
        return name == "localhost" || name == "127.0.0.1" || name == "::1"
}</span>

// Start implements the stmp.Auth's Start.
func (a *loginAuth) Start(server *smtp.ServerInfo) (string, []byte, error) <span class="cov8" title="5">{
        // Must have TLS, or else localhost server.
        // Note: If TLS is not true, then we can't trust ANYTHING in ServerInfo.
        // In particular, it doesn't matter if the server advertises PLAIN auth.
        // That might just be the attacker saying
        // "it's ok, you can trust me with your password."
        if !server.TLS &amp;&amp; !isLocalhost(server.Name) </span><span class="cov1" title="1">{
                return "", nil, errors.New("unencrypted connection")
        }</span>
        <span class="cov7" title="4">if server.Name != a.host </span><span class="cov4" title="2">{
                return "", nil, errors.New("wrong host name")
        }</span>
        <span class="cov4" title="2">return "LOGIN", nil, nil</span>
}

// Next implements the stmp.Auth's Next.
func (a *loginAuth) Next(fromServer []byte, more bool) ([]byte, error) <span class="cov10" title="7">{
        if !more </span><span class="cov4" title="2">{
                return nil, nil
        }</span>

        <span class="cov8" title="5">if string(fromServer) == "Username:" </span><span class="cov4" title="2">{
                return []byte(a.username), nil
        }</span>
        <span class="cov6" title="3">if string(fromServer) == "Password:" </span><span class="cov4" title="2">{
                return []byte(a.password), nil
        }</span>
        <span class="cov1" title="1">return nil, errors.New("unexpected server challenge: " + string(fromServer))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package mailx

import (
        "crypto/tls"
        "errors"
        "net"
        "net/smtp"
        "strconv"
        "strings"
        "time"
)

// @author valor.

// Dialer is a dialer to an SMTP server.
type Dialer struct {
        // Host represents the host of the SMTP server.
        Host string
        // Port represents the port of the SMTP server.
        Port int
        // Username is the username to use to authenticate to the SMTP server.
        Username string
        // Password is the password to use to authenticate to the SMTP server.
        Password string
        // SSLOnConnect defines whether an SSL connection is used.
        // It should be false while SMTP server use the STARTTLS extension.
        SSLOnConnect bool
        // TSLConfig represents the TLS configuration.
        // It is used for the TLS (when the
        // STARTTLS extension is used) or SSL connection.
        TLSConfig *tls.Config
        // Timeout is passed to net.Dialer's Timeout.
        Timeout time.Duration
}

func (d *Dialer) addr() string <span class="cov8" title="1">{
        return d.Host + ":" + strconv.FormatInt(int64(d.Port), 10)
}</span>

func (d *Dialer) tlsConfig() *tls.Config <span class="cov8" title="1">{
        if d.TLSConfig == nil </span><span class="cov8" title="1">{
                return &amp;tls.Config{ServerName: d.Host}
        }</span>
        <span class="cov0" title="0">return d.TLSConfig</span>
}

func (d *Dialer) smtpClient(conn net.Conn, host string) (*smtp.Client, error) <span class="cov8" title="1">{
        return smtp.NewClient(conn, host)
}</span>

func (d *Dialer) smtpAuth(c *smtp.Client) (smtp.Auth, error) <span class="cov8" title="1">{
        if d.Username == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">ok, auths := c.Extension("AUTH")
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("smtp server doesn't support AUTH")
        }</span>

        <span class="cov8" title="1">if strings.Contains(auths, "CRAM-MD5") </span><span class="cov0" title="0">{
                return smtp.CRAMMD5Auth(d.Username, d.Password), nil
        }</span>
        <span class="cov8" title="1">if strings.Contains(auths, "PLAIN") </span><span class="cov0" title="0">{
                return smtp.PlainAuth("", d.Username, d.Password, d.Host), nil
        }</span>
        <span class="cov8" title="1">if strings.Contains(auths, "LOGIN") </span><span class="cov8" title="1">{
                return &amp;loginAuth{
                        username: d.Username,
                        password: d.Password,
                        host:     d.Host,
                }, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("no authentication mechanism is implemented: " + auths)</span>
}

// Dial dials and authenticates to an SMTP server.
// The returned *Sender should be closed when done using it.
func (d *Dialer) Dial() (*Sender, error) <span class="cov8" title="1">{
        var (
                conn net.Conn
                err  error
        )
        netDialer := &amp;net.Dialer{Timeout: d.Timeout}

        if d.SSLOnConnect </span><span class="cov0" title="0">{
                conn, err = tls.DialWithDialer(netDialer, "tcp", d.addr(), d.tlsConfig())
        }</span> else<span class="cov8" title="1"> {
                // debug: openssl s_client -starttls smtp -ign_eof -crlf -connect &lt;host&gt;:&lt;port&gt;
                conn, err = netDialer.Dial("tcp", d.addr())
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return d.dial(conn)</span>
}

func (d *Dialer) dial(conn net.Conn) (*Sender, error) <span class="cov8" title="1">{
        c, err := d.smtpClient(conn, d.Host)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !d.SSLOnConnect </span><span class="cov8" title="1">{
                if ok, _ := c.Extension("STARTTLS"); ok </span><span class="cov8" title="1">{
                        if err = c.StartTLS(d.tlsConfig()); err != nil </span><span class="cov0" title="0">{
                                c.Close()
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">auth, err := d.smtpAuth(c)
        if err != nil </span><span class="cov0" title="0">{
                c.Close()
                return nil, err
        }</span>

        <span class="cov8" title="1">if auth != nil </span><span class="cov8" title="1">{
                if err = c.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        c.Close()
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return &amp;Sender{c}, nil</span>
}

// DialAndSend opens a connection to the SMTP server,
// sends the given emails and closes the connection.
func (d *Dialer) DialAndSend(m *Message) error <span class="cov8" title="1">{
        s, err := d.Dial()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer s.Close()

        return s.Send(m)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mailx

import (
        "mime"
        "path/filepath"
)

// @author valor.

type file struct {
        // It is the name of file.
        // It is used for 'Content-ID', if the file is embedded.
        filename string
        // If true, the file is attachment.
        // If false, the file is embedded.
        attachment bool

        copier CopyFunc
}

func (f *file) contentType() string <span class="cov10" title="3">{
        mediaType := mime.TypeByExtension(filepath.Ext(f.filename))
        if mediaType == "" </span><span class="cov10" title="3">{
                mediaType = "application/octet-stream"
        }</span>
        <span class="cov10" title="3">return mediaType + `; name="` + f.filename + `"`</span>
}

func (f *file) disposition() string <span class="cov10" title="3">{
        disp := ""
        if f.attachment </span><span class="cov6" title="2">{
                disp = "attachment"
        }</span> else<span class="cov1" title="1"> {
                disp = "inline"
        }</span>
        <span class="cov10" title="3">return disp + `; filename="` + f.filename + `"`</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mailx

import (
        "bytes"
        "crypto/rand"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "io"
        "mime"
        "net/mail"
        "runtime"
        "time"
)

// @author valor.

const (
        charset = "utf-8"

        headerEncoder = mime.BEncoding

        multipartEncoding = "base64"
)

var multipartWriter = func(w io.Writer) io.WriteCloser <span class="cov10" title="6">{
        return base64.NewEncoder(base64.StdEncoding, &amp;multipartBase64Writer{w: w})
}</span>

// CopyFunc is the function that runs when the message is sent.
// It should copy the content of the emails to the io.Writer(SMTP).
type CopyFunc func(io.Writer) (int, error)

// Message represents an email message.
type Message struct {
        header *header
        parts  []*part
        files  []*file
}

func (m *Message) sender() (string, error) <span class="cov1" title="1">{
        if m.header == nil || m.header.from == nil </span><span class="cov0" title="0">{
                return "", errors.New("empty email sender")
        }</span>
        <span class="cov1" title="1">sender := m.header.from.Address
        if sender == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty email sender")
        }</span>
        <span class="cov1" title="1">return sender, nil</span>
}

func (m *Message) rcpt() ([]string, error) <span class="cov1" title="1">{
        if m.header == nil </span><span class="cov0" title="0">{
                return nil, errors.New("empty email rcpt")
        }</span>

        <span class="cov1" title="1">lenTo := len(m.header.to)
        lenCc := len(m.header.cc)
        lenBcc := len(m.header.bcc)
        total := lenTo + lenCc + lenBcc
        if total == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("empty email rcpt")
        }</span>

        <span class="cov1" title="1">rcpt := make([]string, 0, total)
        if lenTo &gt; 0 </span><span class="cov1" title="1">{
                for _, address := range m.header.to </span><span class="cov1" title="1">{
                        rcpt = append(rcpt, address.Address)
                }</span>
        }
        <span class="cov1" title="1">if lenCc &gt; 0 </span><span class="cov0" title="0">{
                for _, address := range m.header.cc </span><span class="cov0" title="0">{
                        rcpt = append(rcpt, address.Address)
                }</span>
        }
        <span class="cov1" title="1">if lenBcc &gt; 0 </span><span class="cov0" title="0">{
                for _, address := range m.header.bcc </span><span class="cov0" title="0">{
                        rcpt = append(rcpt, address.Address)
                }</span>
        }
        <span class="cov1" title="1">return rcpt, nil</span>
}

type part struct {
        ctype  string // Content-Type
        copier CopyFunc
}

func (p *part) contentType() string <span class="cov6" title="3">{
        return p.ctype + "; charset=" + charset
}</span>

type header struct {
        from *mail.Address
        to   []*mail.Address
        cc   []*mail.Address
        bcc  []*mail.Address

        subject string
        datefmt string

        ua string

        extra map[string][]string
}

func (h *header) presets() []string <span class="cov0" title="0">{
        return []string{"FROM", "TO", "CC", "BCC", "SUBJECT", "DATE", "MIME-VERSION", "USER-AGENT", "MESSAGE-ID"}
}</span>

// date returns a valid RFC 5322 date.
func (h *header) date() string <span class="cov6" title="3">{
        if h.datefmt == "" </span><span class="cov6" title="3">{
                return time.Now().Format(time.RFC1123Z)
        }</span>
        <span class="cov0" title="0">return h.datefmt</span>
}

// mimeVersion returns MIME-VERSION
func (h *header) mimeVersion() string <span class="cov6" title="3">{
        return "1.0 (Produced by Mailx)"
}</span>

func (h *header) messageId() (string, error) <span class="cov6" title="3">{
        var buf [32]byte
        _, err := rand.Read(buf[:])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov6" title="3">return "&lt;--" + hex.EncodeToString(buf[:]) + "@GolangMailxMessageID&gt;", nil</span>
}

func (h *header) userAgent() string <span class="cov6" title="3">{
        if h.ua == "" </span><span class="cov6" title="3">{
                return "github/valord577/mailx " + runtime.Version() + " " + runtime.GOOS + "/" + runtime.GOARCH
        }</span>
        <span class="cov0" title="0">return h.ua</span>
}

func (h *header) writeTo(w io.Writer) (int, error) <span class="cov6" title="3">{
        if h.from == nil </span><span class="cov0" title="0">{
                return 0, errors.New("empty email header: 'FROM'")
        }</span>
        <span class="cov6" title="3">if len(h.to) == 0 </span><span class="cov0" title="0">{
                return 0, errors.New("empty email header: 'TO'")
        }</span>
        <span class="cov6" title="3">if h.subject == "" </span><span class="cov0" title="0">{
                return 0, errors.New("empty email header: 'SUBJECT'")
        }</span>

        <span class="cov6" title="3">mid, err := h.messageId()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("failed to generate 'MESSAGE-ID': " + err.Error())
        }</span>

        <span class="cov6" title="3">b := &amp;bytes.Buffer{}

        // MESSAGE-ID
        b.WriteString("MESSAGE-ID: ")
        b.WriteString(headerEncoder.Encode(charset, mid))
        b.WriteString("\r\n")

        // FROM
        b.WriteString("FROM: ")
        b.WriteString(h.from.String())
        b.WriteString("\r\n")

        // TO
        for _, to := range h.to </span><span class="cov7" title="4">{
                b.WriteString("TO: ")
                b.WriteString(to.String())
                b.WriteString("\r\n")
        }</span>

        // CC
        <span class="cov6" title="3">length := len(h.cc)
        if length &gt; 0 </span><span class="cov4" title="2">{
                for _, cc := range h.cc </span><span class="cov4" title="2">{
                        b.WriteString("CC: ")
                        b.WriteString(cc.String())
                        b.WriteString("\r\n")
                }</span>
        }

        // SUBJECT
        <span class="cov6" title="3">b.WriteString("SUBJECT: ")
        b.WriteString(headerEncoder.Encode(charset, h.subject))
        b.WriteString("\r\n")

        // DATE
        b.WriteString("DATE: ")
        b.WriteString(headerEncoder.Encode(charset, h.date()))
        b.WriteString("\r\n")

        // MIME-VERSION
        b.WriteString("MIME-VERSION: ")
        b.WriteString(headerEncoder.Encode(charset, h.mimeVersion()))
        b.WriteString("\r\n")

        // USER-AGENT
        b.WriteString("USER-AGENT: ")
        b.WriteString(headerEncoder.Encode(charset, h.userAgent()))
        b.WriteString("\r\n")

        // extra headers
        length = len(h.extra)
        if length &gt; 0 </span><span class="cov0" title="0">{
                for _, key := range h.presets() </span><span class="cov0" title="0">{
                        delete(h.extra, key)
                }</span>
        }

        <span class="cov6" title="3">length = len(h.extra)
        if length &gt; 0 </span><span class="cov0" title="0">{
                for k, vs := range h.extra </span><span class="cov0" title="0">{
                        for _, v := range vs </span><span class="cov0" title="0">{
                                b.WriteString(k)
                                b.WriteString(": ")
                                b.WriteString(headerEncoder.Encode(charset, v))
                                b.WriteString("\r\n")
                        }</span>
                }
        }

        <span class="cov6" title="3">return w.Write(b.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package mailx

import (
        "crypto/rand"
        "encoding/hex"
        "errors"
        "io"
        "net/mail"
        "strings"
)

// @author valor.

// NewMessage creates a new email message.
func NewMessage() *Message <span class="cov10" title="3">{
        return &amp;Message{
                header: &amp;header{
                        to:  make([]*mail.Address, 0),
                        cc:  make([]*mail.Address, 0),
                        bcc: make([]*mail.Address, 0),

                        extra: make(map[string][]string),
                },
                parts: make([]*part, 0),
                files: make([]*file, 0),
        }
}</span>

// SetSender sets the header of email message: 'FROM'.
func (m *Message) SetSender(address string) <span class="cov6" title="2">{
        m.header.from = &amp;mail.Address{
                Name:    "",
                Address: address,
        }
}</span>

// SetFrom sets the header of email message: 'FROM'.
func (m *Message) SetFrom(sender *mail.Address) <span class="cov1" title="1">{
        m.header.from = sender
}</span>

// SetTo sets the header of email message: 'TO'.
func (m *Message) SetTo(address ...string) <span class="cov6" title="2">{
        to := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov10" title="3">{
                to = append(to, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov6" title="2">m.header.to = to</span>
}

// SetTo adds the header of email message: 'TO'.
func (m *Message) AddTo(address ...string) <span class="cov1" title="1">{
        to := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov1" title="1">{
                to = append(to, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov1" title="1">m.header.to = append(m.header.to, to...)</span>
}

// SetRcptTo sets the header of email message: 'TO'.
func (m *Message) SetRcptTo(to ...*mail.Address) <span class="cov0" title="0">{
        m.header.to = to
}</span>

// AddRcptTo adds the header of email message: 'TO'.
func (m *Message) AddRcptTo(to ...*mail.Address) <span class="cov0" title="0">{
        m.header.to = append(m.header.to, to...)
}</span>

// SetCc sets the header of email message: 'CC'.
func (m *Message) SetCc(address ...string) <span class="cov0" title="0">{
        cc := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov0" title="0">{
                cc = append(cc, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov0" title="0">m.header.cc = cc</span>
}

// AddCc adds the header of email message: 'CC'.
func (m *Message) AddCc(address ...string) <span class="cov1" title="1">{
        cc := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov1" title="1">{
                cc = append(cc, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov1" title="1">m.header.cc = append(m.header.cc, cc...)</span>
}

// SetRcptCc sets the header of email message: 'CC'.
func (m *Message) SetRcptCc(cc ...*mail.Address) <span class="cov1" title="1">{
        m.header.cc = cc
}</span>

// AddRcptCc adds the header of email message: 'CC'.
func (m *Message) AddRcptCc(cc ...*mail.Address) <span class="cov0" title="0">{
        m.header.cc = append(m.header.cc, cc...)
}</span>

// SetBcc sets the header of email message: 'BCC'.
func (m *Message) SetBcc(address ...string) <span class="cov1" title="1">{
        bcc := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov1" title="1">{
                bcc = append(bcc, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov1" title="1">m.header.bcc = bcc</span>
}

// AddBcc adds the header of email message: 'BCC'.
func (m *Message) AddBcc(address ...string) <span class="cov0" title="0">{
        bcc := make([]*mail.Address, 0, len(address))
        for _, addr := range address </span><span class="cov0" title="0">{
                bcc = append(bcc, &amp;mail.Address{
                        Name:    "",
                        Address: addr,
                })
        }</span>
        <span class="cov0" title="0">m.header.bcc = append(m.header.bcc, bcc...)</span>
}

// SetRcptBcc sets the header of email message: 'BCC'.
func (m *Message) SetRcptBcc(bcc ...*mail.Address) <span class="cov0" title="0">{
        m.header.bcc = bcc
}</span>

// AddRcptBcc adds the header of email message: 'BCC'.
func (m *Message) AddRcptBcc(bcc ...*mail.Address) <span class="cov0" title="0">{
        m.header.bcc = append(m.header.bcc, bcc...)
}</span>

// SetSubject sets the header of email message: 'SUBJECT'.
func (m *Message) SetSubject(subject string) <span class="cov10" title="3">{
        m.header.subject = subject
}</span>

// SetDate sets the header of email message: 'DATE'.
func (m *Message) SetDate(datefmt string) <span class="cov0" title="0">{
        m.header.datefmt = datefmt
}</span>

// SetUserAgent sets the header of email message: 'USER-AGENT'.
func (m *Message) SetUserAgent(ua string) <span class="cov0" title="0">{
        m.header.ua = ua
}</span>

// AddHeader adds other headers of email message.
func (m *Message) AddHeader(key string, value ...string) <span class="cov0" title="0">{
        k := strings.ToUpper(key)
        m.header.extra[k] = value
}</span>

// SetCopierBody sets a custom part of the body of email message.
func (m *Message) SetCopierBody(contentType string, copier CopyFunc) <span class="cov0" title="0">{
        m.parts = []*part{
                {
                        ctype:  contentType,
                        copier: copier,
                },
        }
}</span>

// AddCopierBody adds a custom part of the body of email message.
func (m *Message) AddCopierBody(contentType string, copier CopyFunc) <span class="cov0" title="0">{
        m.parts = append(m.parts,
                &amp;part{
                        ctype:  contentType,
                        copier: copier,
                },
        )
}</span>

func newTextCopier(s string) CopyFunc <span class="cov10" title="3">{
        return func(w io.Writer) (int, error) </span><span class="cov10" title="3">{
                return io.WriteString(w, s)
        }</span>
}

// SetPlainBody sets a text part of the body of email message.
func (m *Message) SetPlainBody(text string) <span class="cov6" title="2">{
        m.parts = []*part{
                {
                        ctype:  "text/plain",
                        copier: newTextCopier(text),
                },
        }
}</span>

// AddPlainBody adds a text part of the body of email message.
func (m *Message) AddPlainBody(text string) <span class="cov0" title="0">{
        m.parts = append(m.parts,
                &amp;part{
                        ctype:  "text/plain",
                        copier: newTextCopier(text),
                },
        )
}</span>

// SetHtmlBody sets a html part of the body of email message.
func (m *Message) SetHtmlBody(html string) <span class="cov1" title="1">{
        m.parts = []*part{
                {
                        ctype:  "text/html",
                        copier: newTextCopier(html),
                },
        }
}</span>

// AddHtmlBody adds a html part of the body of email message.
func (m *Message) AddHtmlBody(html string) <span class="cov0" title="0">{
        m.parts = append(m.parts,
                &amp;part{
                        ctype:  "text/html",
                        copier: newTextCopier(html),
                },
        )
}</span>

// Attach adds a attachment of email message.
func (m *Message) Attach(filename string, copier CopyFunc) <span class="cov6" title="2">{
        f := &amp;file{
                filename:   filename,
                attachment: true,
                copier:     copier,
        }
        m.files = append(m.files, f)
}</span>

// Embed adds a embedded file of email message.
func (m *Message) Embed(cid string, copier CopyFunc) <span class="cov1" title="1">{
        f := &amp;file{
                filename:   cid,
                attachment: false,
                copier:     copier,
        }
        m.files = append(m.files, f)
}</span>

// WriteTo implements io.WriterTo.
// It dumps the whole message to SMTP server.
func (m *Message) WriteTo(w io.Writer) (int64, error) <span class="cov10" title="3">{
        if m.header == nil </span><span class="cov0" title="0">{
                return 0, errors.New("empty email header")
        }</span>

        <span class="cov10" title="3">var (
                s int = 0
                n int

                err error
        )

        var buf [30]byte
        _, err = rand.Read(buf[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">boundary := "--GolangMailxBoundary" + hex.EncodeToString(buf[:])

        partStart := "--" + boundary
        partClose := "--" + boundary + "--"

        n, err = m.header.writeTo(w)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(w, "Content-Type: multipart/mixed;\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(w, " boundary="+boundary+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(w, "\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        if len(m.parts) &gt; 0 </span><span class="cov10" title="3">{
                for _, part := range m.parts </span><span class="cov10" title="3">{
                        n, err = writePart(partStart, part, w)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov10" title="3">s += n</span>
                }
        }

        <span class="cov10" title="3">if len(m.files) &gt; 0 </span><span class="cov10" title="3">{
                for _, file := range m.files </span><span class="cov10" title="3">{
                        n, err = writeFile(partStart, file, w)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov10" title="3">s += n</span>
                }
        }

        <span class="cov10" title="3">n, err = io.WriteString(w, partClose+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        return int64(s), nil</span>
}

func writePart(partStart string, part *part, out io.Writer) (int, error) <span class="cov10" title="3">{
        var (
                s int = 0
                n int

                err error
        )

        n, err = io.WriteString(out, partStart+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(out, "Content-Type: "+part.contentType()+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(out, "Content-Transfer-Encoding: "+multipartEncoding+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(out, "\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        // Headers ended, write the body of part
        partWriter := multipartWriter(out)
        n, err = part.copier(partWriter)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">partWriter.Close()
        s += n

        n, err = io.WriteString(out, "\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        return s, nil</span>
}

func writeFile(partStart string, file *file, out io.Writer) (int, error) <span class="cov10" title="3">{
        var (
                s int = 0
                n int

                err error
        )

        n, err = io.WriteString(out, partStart+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        // The name of file may contain non-ascii characters.
        n, err = io.WriteString(out, "Content-Type: "+headerEncoder.Encode(charset, file.contentType())+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        // The name of file may contain non-ascii characters.
        n, err = io.WriteString(out, "Content-Disposition: "+headerEncoder.Encode(charset, file.disposition())+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        if !file.attachment </span><span class="cov1" title="1">{
                // The name of file may contain non-ascii characters.
                n, err = io.WriteString(out, "Content-ID: &lt;"+headerEncoder.Encode(charset, file.filename)+"&gt;\r\n")
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov1" title="1">s += n</span>
        }

        <span class="cov10" title="3">n, err = io.WriteString(out, "Content-Transfer-Encoding: "+multipartEncoding+"\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        n, err = io.WriteString(out, "\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        // Headers ended, write the body of file
        partWriter := multipartWriter(out)
        n, err = file.copier(partWriter)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">partWriter.Close()
        s += n

        n, err = io.WriteString(out, "\r\n")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="3">s += n

        return s, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package mailx

import (
        "io"
        "net/smtp"
)

// @author valor.

// Sender sends emails via *smtp.Client
type Sender struct {
        *smtp.Client
}

// Send sends the given emails.
func (s *Sender) Send(m *Message) error <span class="cov8" title="1">{
        from, err := m.sender()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rcpt, err := m.rcpt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.send(from, rcpt, m)</span>
}

// SendOne sends a message implements io.WriterTo
func (s *Sender) send(from string, to []string, msg io.WriterTo) error <span class="cov8" title="1">{
        if err := s.Mail(from); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, addr := range to </span><span class="cov8" title="1">{
                if err := s.Rcpt(addr); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">w, err := s.Data()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err = msg.WriteTo(w); err != nil </span><span class="cov0" title="0">{
                w.Close()
                return err
        }</span>
        <span class="cov8" title="1">return w.Close()</span>
}

// Close sends the QUIT command and closes the connection to the server.
func (s *Sender) Close() error <span class="cov8" title="1">{
        return s.Quit()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package mailx

import "io"

// @author valor.

// According to
//  1. RFC 2045, 6.7. (page 21) for quoted-printable
//  2. RFC 2045, 6.8. (page 25) for base64
//
// The encoded output stream must be represented in lines
// with no more than 76 characters per line.
const maxLineLength = 76

type multipartBase64Writer struct {
        w io.Writer
}

// Write implements io.Writer
func (w *multipartBase64Writer) Write(p []byte) (int, error) <span class="cov9" title="12">{
        length := len(p)
        if length &lt;= maxLineLength </span><span class="cov9" title="11">{
                return w.write(p)
        }</span>

        <span class="cov1" title="1">sum := 0

        doit := true
        index := 0
        for doit </span><span class="cov3" title="2">{
                if index &gt;= length </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov3" title="2">end := index + maxLineLength
                if end &gt;= length </span><span class="cov1" title="1">{
                        end = length
                        doit = false
                }</span>
                <span class="cov3" title="2">n, err := w.write(p[index:end])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov3" title="2">sum += n
                index += maxLineLength</span>
        }
        <span class="cov1" title="1">return sum, nil</span>
}

func (w *multipartBase64Writer) write(p []byte) (int, error) <span class="cov10" title="13">{
        n, err := w.w.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="13">x, err := w.w.Write([]byte("\r\n"))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov10" title="13">return n + x, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
